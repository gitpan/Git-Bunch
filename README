NAME
    Git::Bunch - Manage gitbunch directory (directory which contain git
    repos)

VERSION
    version 0.29

SYNOPSIS
    To check the status of bunch (will do a 'git status' for each git repo
    inside the bunch and report which repos are 'unclean', e.g. needs
    commit, has untracked files, etc):

     % gitbunch check ~/repos

    To synchronize bunch to another (will do a 'git pull/push' for each git
    repo, and do an rsync for everything else):

     % gitbunch sync ~/repos /mnt/laptop/repos

DESCRIPTION
    A gitbunch or bunch directory is just a term I coined to refer to a
    directory which contains, well, a bunch of git repositories. It can also
    contain other stuffs like files and non-git repositories (but they must
    be dot-dirs). Example:

     repos/            -> a gitbunch dir
       proj1/          -> a git repo
       proj2/          -> ditto
       perl-Git-Bunch/ -> ditto
       ...
       .foo/           -> a non-git dir
       README.txt      -> file

    A little bit of history: after git got popular, in 2008 I started using
    it for software projects, replacing Subversion and Bazaar. Soon, I moved
    everything to git: notes & writings, Emacs .org agenda files,
    configuration, even temporary downloads/browser-saved HTML files.
    Currently, except large media files, all my personal data resides in git
    repositories. I put them all in ~/repos (and add symlinks to various
    places for convenience). This setup makes it easy to sync to laptops,
    backup to disk, etc. Git::Bunch is the library/script I wrote to do
    this.

    See also File::RsyBak, which I wrote to backup everything else.

FUNCTIONS
    None of the functions are exported by default, but they are exportable.

    None are exported by default, but they are exportable.

  check_bunch(%args) -> [status, msg, result, meta]
    Will perform a 'git status' for each git repositories inside the bunch
    and report which repositories are clean/unclean.

    Will die if can't chdir into bunch or git repository.

    Arguments ('*' denotes required arguments):

    *   exclude_files => *bool*

        Exclude files from processing.

        This only applies to 'backup*bunch' and 'sync*bunch' operations.
        Operations like 'check*bunch' and 'exec*bunch' already ignore these
        and only operate on git repos.

    *   exclude_non_git_dirs => *bool*

        Exclude non-git dirs from processing.

        This only applies to 'backup*bunch' and 'sync*bunch' operations.
        Operations like 'check*bunch' and 'exec*bunch' already ignore these
        and only operate on git repos.

    *   exclude_repos => *array*

        Exclude some repos from processing.

    *   exclude_repos_pat => *str*

        Specify regex pattern of repos to exclude.

    *   include_repos => *array*

        Specific git repos to sync, if not specified all repos in the bunch
        will be processed.

    *   include_repos_pat => *str*

        Specify regex pattern of repos to include.

    *   sort => *str* (default: "-mtime")

        Order entries in bunch.

    *   source* => *str*

        Directory to check.

    Return value:

    Returns an enveloped result (an array). First element (status) is an
    integer containing HTTP status code (200 means OK, 4xx caller error, 5xx
    function error). Second element (msg) is a string containing error
    message, or 'OK' if status is 200. Third element (result) is optional,
    the actual result. Fourth element (meta) is called result metadata and
    is optional, a hash that contains extra information.

  exec_bunch(%args) -> [status, msg, result, meta]
    For each git repository in the bunch, will chdir to it and execute
    specified command.

    Arguments ('*' denotes required arguments):

    *   command* => *str*

        Command to execute.

    *   exclude_files => *bool*

        Exclude files from processing.

        This only applies to 'backup*bunch' and 'sync*bunch' operations.
        Operations like 'check*bunch' and 'exec*bunch' already ignore these
        and only operate on git repos.

    *   exclude_non_git_dirs => *bool*

        Exclude non-git dirs from processing.

        This only applies to 'backup*bunch' and 'sync*bunch' operations.
        Operations like 'check*bunch' and 'exec*bunch' already ignore these
        and only operate on git repos.

    *   exclude_repos => *array*

        Exclude some repos from processing.

    *   exclude_repos_pat => *str*

        Specify regex pattern of repos to exclude.

    *   include_repos => *array*

        Specific git repos to sync, if not specified all repos in the bunch
        will be processed.

    *   include_repos_pat => *str*

        Specify regex pattern of repos to include.

    *   sort => *str* (default: "-mtime")

        Order entries in bunch.

    *   source* => *str*

        Directory to check.

    Return value:

    Returns an enveloped result (an array). First element (status) is an
    integer containing HTTP status code (200 means OK, 4xx caller error, 5xx
    function error). Second element (msg) is a string containing error
    message, or 'OK' if status is 200. Third element (result) is optional,
    the actual result. Fourth element (meta) is called result metadata and
    is optional, a hash that contains extra information.

  sync_bunch(%args) -> [status, msg, result, meta]
    For each git repository in the bunch, will perform a 'git pull/push' for
    each branch. If repository in destination doesn't exist, it will be
    rsync-ed first from source. When 'git pull' fails, will exit to let you
    fix the problem manually.

    For all other non-git repos, will simply synchronize by one-way rsync.

    Arguments ('*' denotes required arguments):

    *   create_bare_target => *bool*

        Whether to create bare git repo when target does not exist.

        When target repo does not exist, gitbunch can either copy the source
        repo using "rsync" (the default, if this setting is undefined), or
        it can create target repo with "git init --bare" (if this setting is
        set to 1), or it can create target repo with "git init" (if this
        setting is set to 0).

        Bare git repositories contain only contents of the .git folder
        inside the directory and no working copies of your source files.

        Creating bare repos are apt for backup purposes since they are more
        space-efficient.

        Non-repos will still be copied/rsync-ed.

    *   delete_branch => *bool* (default: 0)

        Whether to delete branches in dest repos not existing in source
        repos.

    *   exclude_files => *bool*

        Exclude files from processing.

        This only applies to 'backup*bunch' and 'sync*bunch' operations.
        Operations like 'check*bunch' and 'exec*bunch' already ignore these
        and only operate on git repos.

    *   exclude_non_git_dirs => *bool*

        Exclude non-git dirs from processing.

        This only applies to 'backup*bunch' and 'sync*bunch' operations.
        Operations like 'check*bunch' and 'exec*bunch' already ignore these
        and only operate on git repos.

    *   exclude_repos => *array*

        Exclude some repos from processing.

    *   exclude_repos_pat => *str*

        Specify regex pattern of repos to exclude.

    *   include_repos => *array*

        Specific git repos to sync, if not specified all repos in the bunch
        will be processed.

    *   include_repos_pat => *str*

        Specify regex pattern of repos to include.

    *   rsync_opt_maintain_ownership => *bool* (default: 0)

        Whether or not, when rsync-ing from source, we use -a (= -rlptgoD)
        or -rlptD (-a minus -go).

        Sometimes using -a results in failure to preserve permission modes
        on sshfs-mounted filesystem, while -rlptD succeeds, so by default we
        don't maintain ownership. If you need to maintain ownership (e.g.
        you run as root and the repos are not owned by root), turn this
        option on.

    *   sort => *str* (default: "-mtime")

        Order entries in bunch.

    *   source* => *str*

        Directory to check.

    *   target* => *str*

        Destination bunch.

    Return value:

    Returns an enveloped result (an array). First element (status) is an
    integer containing HTTP status code (200 means OK, 4xx caller error, 5xx
    function error). Second element (msg) is a string containing error
    message, or 'OK' if status is 200. Third element (result) is optional,
    the actual result. Fourth element (meta) is called result metadata and
    is optional, a hash that contains extra information.

FAQ
TODO
    *   Can't handle bare source repos

SEE ALSO
    mr, http://joeyh.name/code/mr/ . You probably want to use this instead.
    mr supports other control version software aside from git, doesn't
    restrict you to put all your repos in one directory, supports more
    operations, and has been developed since 2007. Had I known about mr, I
    probably wouldn't have started Git::Bunch. On the other hand, Git::Bunch
    is simpler (I think), doesn't require any config file, and can copy/sync
    files/directories not under source control. I mainly use Git::Bunch to
    quickly: 1) check whether there are any of my repositories which have
    uncommitted changes; 2) synchronize (pull/push) to other locations. I
    put all my data in one big gitbunch directory; I find it simpler.
    Git::Bunch works for me and I use it daily.

AUTHOR
    Steven Haryanto <stevenharyanto@gmail.com>

COPYRIGHT AND LICENSE
    This software is copyright (c) 2013 by Steven Haryanto.

    This is free software; you can redistribute it and/or modify it under
    the same terms as the Perl 5 programming language system itself.

